package code.semantics;

import code.Environment.Environment;
import code.model.Token;
import code.node.AssignmentNode;
import code.node.ExpressionNode;
import code.node.Node;
import code.parser.CustomExceptions;

import java.util.ArrayList;
import java.util.List;

public class SemanticAnalyzer2 {
    private Environment environment;

    public SemanticAnalyzer2(Environment environment) {
        this.environment = environment;
    }

    public void analyze(List<Token> tokens, Node rootNode) throws CustomExceptions {
        checkVariableDeclarations(tokens);
        checkDisplayUsage(tokens);
        checkVariableUsage(tokens);

        if (rootNode != null) {
            checkTypeCompatibility(rootNode);
        }
    }

    private void checkVariableDeclarations(List<Token> tokensList) throws CustomExceptions {
        List<String> declaredVariables = new ArrayList<>();
        boolean withinExecutableCode = false;

        for (Token token : tokensList) {
            if (token.getValue().equals("BEGIN CODE")) {
                withinExecutableCode = true;
            } else if (token.getValue().equals("END CODE")) {
                break;
            } else if (withinExecutableCode && isDeclarationToken(token)) {
                declaredVariables.add(token.getNextToken().getValue()); // Add declared variable to the list
            } else if (isExecutableToken(token)) {
                withinExecutableCode = true;
            }
        }
    }

    private boolean isDeclarationToken(Token token) {
        return token.getType() == Token.TokenType.DATATYPE;
    }

    private boolean isExecutableToken(Token token) {
        return token.getType() != Token.TokenType.DATATYPE && token.getType() != Token.TokenType.ENDLINE;
    }

    private void checkDisplayUsage(List<Token> tokensList) throws CustomExceptions {
        List<String> declaredVariables = new ArrayList<>();
        boolean withinExecutableCode = false;

        for (Token token : tokensList) {
            if (token.getValue().equals("BEGIN CODE")) {
                withinExecutableCode = true;
            } else if (token.getValue().equals("END CODE")) {
                break;
            } else if (withinExecutableCode && isDeclarationToken(token)) {
                declaredVariables.add(token.getNextToken().getValue()); // Add declared variable to the list
            } else if (isExecutableToken(token)) {
                withinExecutableCode = true;
            }
        }

        for (Token token : tokensList) {
            if (token.getValue().equals("DISPLAY")) {
                for (Token displayToken : token.getChildren()) {
                    if (displayToken.getType() == Token.TokenType.VARIABLE) {
                        String variableName = displayToken.getValue();
                        if (!declaredVariables.contains(variableName)) {
                            throw new CustomExceptions("Variable '" + variableName + "' is not defined.");
                        }
                    }
                }
            }
        }
    }

    private void checkVariableUsage(List<Token> tokensList) throws CustomExceptions {
        List<String> declaredVariables = new ArrayList<>();
        boolean withinExecutableCode = false;

        for (Token token : tokensList) {
            if (token.getValue().equals("BEGIN CODE")) {
                withinExecutableCode = true;
            } else if (token.getValue().equals("END CODE")) {
                break;
            } else if (withinExecutableCode && isDeclarationToken(token)) {
                declaredVariables.add(token.getNextToken().getValue()); // Add declared variable to the list
            } else if (isExecutableToken(token)) {
                withinExecutableCode = true;
            }
        }

        for (Token token : tokensList) {
            if (token.getType() == Token.TokenType.VARIABLE && !declaredVariables.contains(token.getValue())) {
                throw new CustomExceptions("Variable '" + token.getValue() + "' is used before it is declared.");
            }
        }
    }

    private void checkTypeCompatibility(Node rootNode) throws CustomExceptions {
        traverseAST(rootNode);
    }

    private void traverseAST(Node node) throws CustomExceptions {
        if (node instanceof AssignmentNode) {
            checkAssignmentTypeCompatibility((AssignmentNode) node);
        } else if (node instanceof ExpressionNode) {
            checkExpressionTypeCompatibility((ExpressionNode) node);
        }

        for (Node child : node.getChildren()) {
            traverseAST(child);
        }
    }

    private void checkAssignmentTypeCompatibility(AssignmentNode assignmentNode) throws CustomExceptions {
        String variableName = assignmentNode.getVariableName();
        String dataType = environment.getVariableType(variableName);

        // Implement type compatibility checks based on dataType and the value being assigned
    }

    private void checkExpressionTypeCompatibility(ExpressionNode expressionNode) throws CustomExceptions {
        // Implement checks for type compatibility in expressions
    }

    public static void main(String[] args) throws CustomExceptions {
        List<Token> tokenlist = new ArrayList<>();
        List<Node> ASTNode = new ArrayList<>();
        Environment environment1 = new Environment();
        environment1.setVariable("a", 1);
        environment1.setVariable("b", 2);
        environment1.setVariable("d", 3);
        tokenlist.add(new Token(Token.TokenType.DISPLAY, "DISPLAY", true));
        tokenlist.add(new Token(Token.TokenType.VARIABLE, "a", false));
        tokenlist.add(new Token(Token.TokenType.ENDLINE, "end of line", true));

        SemanticAnalyzer2 semanticAnalyzer = new SemanticAnalyzer2(environment1);
        semanticAnalyzer.analyze(tokenlist, null);
    }
}
